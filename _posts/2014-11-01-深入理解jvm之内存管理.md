---
layout : life
title : "深入理解jvm之内存管理"
category : 深入理解java
duoshuo: true
date : 2014-11-05
---
------------
java虚拟机在执行Java程序的过程中会将内存分为若干个不同的区域，各有各的作用，创建时间和销毁时间。（如下图）
![onepiece](/life/picture/date.jpg)

-------------

##程序计数器：

-------------

* 较小的内存空间，字节码解释器工作时就是通过改变计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基本功能。
* java虚拟机的多线程通过线程轮流切换分配处理器执行时间来实现的，为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储。
* **Native**方法，计数器值为空，内存区域唯一一个在Java虚拟机中没有规定任何OutOfMemoryError情况的区域。

-------------

##Java虚拟机栈

--------------
* 线程私有，生命周期和线程相同。
* 描述的是Java方法执行的内存模型：每个方法被执行的时候同时创建一个栈帧，用来存储局部变量表，操作栈，动态链接，方法等。每一个方法被调用到结束都意味着虚拟机栈从入栈到出栈的过程。
* 局部变量表存放编译期可知的
	* 基本数据类型（byte,char,short,int,long, float, double,boolean)
	* 对象引用(reference类型，不等同于对象本身，可以使一个引用指针，也可以指向一个对象的句柄)
	* returnAddress类型(指向一条字节码指令的地址)
* 两种异常
  * StackOverflowError ：线程请求深度大于虚拟机所允许的深度。
  * OutOfMemoryError: 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存。

 -----------

## 本地方法栈

------------

* 与虚拟机栈发挥的作用是非常相似的。
	* 虚拟机栈为虚拟机执行**Java方法**，本地方法为虚拟机使用**Native方法**。
* 两种异常
  * StackOverflowError ：线程请求深度大于虚拟机所允许的深度。
  * OutOfMemoryError: 如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存。
 
 -------------
 
 ##Java堆
 
 -------------
 
 * java虚拟机所管理的内存中最大的一块，所有线程共享的一块内存区域。
 * java虚拟机启动时创建，唯一目的是存放对象实例。
 * 垃圾收集器管理的区域，**GC堆(Garbage Collected Heap)**
 * 可以物理不连续，只要逻辑连续。
 * 当堆中没有内存完成实例分配，并且堆无法再扩展，抛出OutOfMemoryError异常。
 
 --------------
 
 #方法区
 
 ------------

  * 运行时常量区：用来存放编译期声场的各种字面量和符号引用，这部分内容在加载后存放在方法区的运行时常量池。
	* 当常量池无法申请到内存时，抛出OutOfMemoryError异常。

-------------

##对象访问

------------

* **句柄方式**
	* java堆中会划分出一块内存当作句柄池，reference中存储的就是对象的句柄地址。
* **指针方式**
	* reference中存储的就是对象地址。
* 优势：
	* 句柄访问的好处：reference中存储的是稳定的句柄地址，对象被移动只改变句柄中的实例指针，reference本身不需要修改。
	* 指针访问的优点：速度更快，减少开销。
	
------------

* 句柄访问方式：

-----------

![jubing](/life/picture/jubing.png)

--------------

* 指针访问方式：

-----------------

![zhizheng](/life/picture/zhizheng.png)

----------