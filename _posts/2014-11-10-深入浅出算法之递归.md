---
layout : life
title : "深入浅出算法之递归"
category : 深入浅出算法
duoshuo: true
date : 2014-11-10
---
------------

##递归

------------

* **递归算法**：直接或者间接调用自身的算法。
* **递归函数**：函数自身给出定义的函数。

------------

##常见递归函数

------------

* **阶乘**
* **Fibonacci数列**
* **全排列**
* **整数划分**

-------------

###阶乘算法源码：

-----------
 {% highlight C %}
 int factorial(int n)
 {
	if(n==0) return 1;
	return n * factorial(n-1);
 }
{% endhighlight %}

------------

###Fibonacci算法源码：

-----------
 {% highlight C %}
 int fibonacci(int n)
 {
	if(n<=1) return 1;
	return fibonacci(n-1)+fibonacci(n-2);
 }
{% endhighlight %}

------------

###全排列算法源码：(不含重复元素)

####全排列问题实质是将一个n个规模的排列问题简化成n个n-1规模的子问题。

-----------
 {% highlight C %}
#include <iostream>
using namespace std;

template<class Type>
void Perm(Type list[], int first, int last)
{
	if(first == last)
	{
		for(int i = 0; i <= last; i++)
			cout<<list[i]<<" ";
		cout<<endl;
	}
	else
	{
		for(int i = first; i <= last; i++)
		{
			Swap(list[first],list[i]);
			Perm(list,first+1,last);
			Swap(list[first],list[i]);
		}
	}
}

template<class Type>
inline void Swap(Type &a, Type &b)
{
	Type temp = a;
		 a = b;
		 b = temp;
}

int main()
{
	int list[]={1,2,3};
	Perm(list,0,2);
    return 0;
}

{% endhighlight %}

------------

 {% highlight C %}
#include <stdio.h>
#define num 4

void perm(int A[], int k, int m);
void swap(int &a, int &b);
bool ok(int A[], int k, int i);

int main()
{
	int A[num]={1,2,3,3};
	perm(A,0,num-1);
	return 0;
}

/* ok函数用于判别重复元素 */
bool ok(int A[], int k, int i)
{
	if (i > k)
		for (int t=k; t<i; t++)			// 若在之前替换过相同值, 则返回flase
			if(A[t] == A[i])
				return false;
	return true;
}

void perm(int A[], int k, int m)
{
	int i;

	if(k == m)
	{
		for(i=0; i<=m; i++)
			printf("%d ", A[i]);
		printf("\n");
	}
	else
		for(i=k; i<=m; i++)
		{
			if(!ok(A, k, i))		// 进行重复检测
				continue;
			swap(A[k], A[i]);
			perm(A, k+1, m);
			swap(A[k], A[i]);
		}
}

void swap(int &a, int &b)
{
	int temp = a;
		a = b;
		b = temp;
}

{% endhighlight %}

------------


