---
layout : life
title : "深入浅出算法之贪心算法"
category : 深入浅出算法
duoshuo: true
date : 2014-11-11
---
------------

##贪心算法

------------
* 贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的**局部最优**选择。
* 贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。
* 在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。

* 贪心算法的基本要素
 * **贪心选择性质**：所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到
 * **最优子结构性质**：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。
* 常见问题
 * **活动安排**
 * **最优装载**
 * **单源最短路径**
 * **最小生成树**

-------------

##活动安排

-------------

* 活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。
* 问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。

* 设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si <fi 。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。
* 由于输入的活动以其完成时间的非减序排列，所以算法greedySelector每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。算法greedySelector的效率极高。当输入的活动已按结束时间的非减序排列，算法只需**O(n)**的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用**O(nlogn)**的时间重排。 
 {% highlight C++ %}
	int greedySelector(int s [], int f [], boolean a[],int n)
   { //起始时间s,结束时间f按照结束时间的非减序排列。
      a[1]=true;
      int j=1;
      int count=1;
      for (int i=2;i<=n;i++) {
        if (s[i]>=f[j]) {
          a[i]=true;
          j=i;
          count++;
          }
        else a[i]=false;
        }
      return count;
   }
{% endhighlight %}

----------------------

##例：设待安排的11个活动的开始时间和结束时间按结束时间的非减序排列如下：

--------------------

![onepiece](/life/picture/tanxin1.png)
![onepiece](/life/picture/tanxin2.png)

--------------------
