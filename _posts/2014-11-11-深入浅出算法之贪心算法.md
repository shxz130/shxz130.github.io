---
layout : life
title : "深入浅出算法之贪心算法"
category : 深入浅出算法
duoshuo: true
date : 2014-11-11
---
------------

##贪心算法

------------
* 贪心算法总是作出在当前看来最好的选择。也就是说贪心算法并不从整体最优考虑，它所作出的选择只是在某种意义上的**局部最优**选择。
* 贪心算法不能对所有问题都得到整体最优解，但对许多问题它能产生整体最优解。
* 在一些情况下，即使贪心算法不能得到整体最优解，其最终结果却是最优解的很好近似。

* 贪心算法的基本要素
 * **贪心选择性质**：所求问题的整体最优解可以通过一系列局部最优的选择，即贪心选择来达到
 * **最优子结构性质**：当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。
* 常见问题
 * **活动安排**
 * **最优装载**
 * **单源最短路径**
 * **最小生成树**

-------------

##活动安排

-------------

* 活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。
* 问题要求高效地安排一系列争用某一公共资源的活动。贪心算法提供了一个简单、漂亮的方法使得尽可能多的活动能兼容地使用公共资源。

* 设有n个活动的集合E={1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动i都有一个要求使用该资源的起始时间si和一个结束时间fi,且si <fi 。如果选择了活动i，则它在半开时间区间[si, fi)内占用资源。若区间[si, fi)与区间[sj, fj)不相交，则称活动i与活动j是相容的。也就是说，当si≥fj或sj≥fi时，活动i与活动j相容。
* 由于输入的活动以其完成时间的非减序排列，所以算法greedySelector每次总是选择具有最早完成时间的相容活动加入集合A中。直观上，按这种方法选择相容活动为未安排活动留下尽可能多的时间。也就是说，该算法的贪心选择的意义是使剩余的可安排时间段极大化，以便安排尽可能多的相容活动。算法greedySelector的效率极高。当输入的活动已按结束时间的非减序排列，算法只需**O(n)**的时间安排n个活动，使最多的活动能相容地使用公共资源。如果所给出的活动未按非减序排列，可以用**O(nlogn)**的时间重排。 
 {% highlight C++ %}
	int greedySelector(int s [], int f [], boolean a[],int n)
   { //起始时间s,结束时间f按照结束时间的非减序排列。
      a[1]=true;
      int j=1;
      int count=1;
      for (int i=2;i<=n;i++) {
        if (s[i]>=f[j]) {
          a[i]=true;
          j=i;
          count++;
          }
        else a[i]=false;
        }
      return count;
   }
{% endhighlight %}

----------------------

##例：设待安排的11个活动的开始时间和结束时间按结束时间的非减序排列如下：

--------------------

![onepiece](/life/picture/tanxin1.png)
![onepiece](/life/picture/tanxin2.png)

--------------------

##背包问题：

--------------------

* 与0-1背包问题类似，所不同的是在选择物品i装入背包时，可以选择物品i的一部分，而不一定要全部装入背包，1≤i≤n。
* 这2类问题都具有最优子结构性质，极为相似，但**背包问题可以用贪心算法求解**，而**0-1背包问题却不能用贪心算法求解**。 
* 用贪心算法解背包问题的基本步骤：
 * 计算每种物品单位重量的价值Vi/Wi
 * 依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包。
 * 将这种物品全部装入背包后，背包内的物品总重量未超过C，则选择单位重量价值次高的物品并尽可能多地装入背包。
 * 依此策略一直地进行下去，直到背包装满为止。
* 贪心选择之所以不能得到最优解是因为在这种情况下，它无法保证最终能将背包装满，部分闲置的背包空间使每公斤背包空间的价值降低了。事实上，在考虑0-1背包问题时，应比较选择该物品和不选择该物品所导致的最终方案，然后再作出最好选择。由此就导出许多互相重叠的子问题。这正是该问题可用动态规划算法求解的另一重要特征。

-----------------------
 {% highlight C++ %}
 float knapsack(float c,float w [], float v [],float x [] )
{
     float opt=0;
     for (int i = 0; i <n; i++) 
     {d[i].w=w[i];  d[i].v=v[i]; d[i].index=i;}
      mergeSort(d);
      for (i=0;i<n;i++) x[i]=0;
      for (i=0;i<n;i++) {
        if (d[i].w>c) break;
        x[d[i].index]=1;
        opt+=d[i].v;
        c-=d[i].w; }
       if (i<n){
			x[d[i].index]=c/d[i].w;
            opt+=x[d[i].index]*d[i].v; 
	   }
        return opt;
}
        
{% endhighlight %}

-----------------

##最优装载

-----------------

* 有一批集装箱要装上一艘载重量为c的轮船。其中集装箱i的重量为Wi。最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。
* 最优装载问题可用贪心算法求解。采用重量最轻者先装的贪心选择策略，可产生最优装载问题的最优解

------------------

##单源最短路径

------------------

* 给定带权有向图G =(V,E)，其中每条边的权是非负实数。另外，还给定V中的一个顶点，称为源。现在要计算从源到所有其他各顶点的最短路长度。这里路的长度是指路上各边权之和。这个问题通常称为单源最短路径问题。
* **算法思想**：
 * 设置顶点集合S并不断地作贪心选择来扩充这个集合。一个顶点属于集合S当且仅当从源到该顶点的最短路径长度已知。
 * 初始时，S中仅含有源。设u是G的某一个顶点，把从源到u且中间只经过S中顶点的路称为从源到u的特殊路径，并用数组dist记录当前每个顶点所对应的最短特殊路径长度。Dijkstra算法每次从V-S中取出具有最短特殊路长度的顶点u，将u添加到S中，同时对数组dist作必要的修改。一旦S包含了所有V中顶点，dist就记录了从源到所有其他顶点之间的最短路径长度。
* 对于具有n个顶点和e条边的带权有向图，如果用带权邻接矩阵表示这个图，那么Dijkstra算法的主循环体需要O(n)时间。这个循环需要执行n-1次，所以完成循环需要O(n2)时间。算法的其余部分所需要时间不超过O(n2)。

----------------
![onepiece](/life/picture/danyuan.jpg)

-----------------------
 {% highlight C++ %}
void Dijkstra(int n,int v,int dist[],int prev[],int c[][])
{    
	bool s[MAX];
	for(int i=1;i<=n;i++)
	{     
		dist[i]=c[v][i]; s[i]=false; 
		if(dist[i]==MAX)prev[i]=0;
		else prev[i]=v; 
	}
    dist[v]=0;s[v]=true;
	for(i=1;i<n;i++)
	{       
		int temp=MAX;  
		int u=v;
		for(int j=1;j<=n;j++)
			if((!s[j])&&(dist[j]<temp)) 
			{
					u=j;  
					temp=dist[j]; 
			}
        s[u]=true;   
		prev[i+1]=u;
	    for(j=1;j<=n;j++)
			if((!s[j])&&(c[u][j]<MAX)) 
			{   
				int newdist=dist[u]+c[u][j];     
				if(newdist<dist[j])
					dist[j]=newdist; 
			}
	} 
}	     
{% endhighlight %}

-------------------

###最小生成树是在数据结构中讲过的知识，所以在这里不做讲解，会在数据结构里讲到。

-------------------