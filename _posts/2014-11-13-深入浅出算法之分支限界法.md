---
layout : life
title : "深入浅出算法之分支限界法"
category : 深入浅出算法
duoshuo: true
date : 2014-11-12
---

##分支限界法

------------

* 概念：一种在问题的**解空间树**上搜索问题解的算法
* **解空间**：将问题的解表示成一个多元组(x1, x2, …, xn)的形式，满足问题显约束的所有多元组定义为关于输入(x1, x2, …, xn)的解空间。
* **解空间树**：树上的每一个结点定义了一个“问题状态”，从根到每一个结点的所有路径定义了这个问题的“状态空间”。从根到叶结点的每一条路径定义了解空间中的一个多元组。
* 与**回溯法**的比较
 * 回溯法：
  * 求解目标：找出解空间树中满足约束条件的**所有解**    
  * 搜索方式：以**深度优先**的方式搜索解空间树
 * 分支限界法
  * 求解目标：找出满足约束条件的**一个解**，或是在满足约束条件的解中找出在某种意义下的**最优解**。
  * 搜索方式：以**广度优先**或以**最小耗费优先**的方式搜索解空间树。
* **搜索策略**
 * 结点的构造
 * 结点的扩展
 * 下一个活结点的生成。
 * 结束舍弃原则(剪枝)。

----------------

###结点的构造

-------------

 * 活结点：一个自身已生成但其儿子还没有全部生成的节点称做活结点
 * 扩展结点：一个正在产生儿子的结点称为扩展结点
 * 死结点：一个所有儿子已经产生的结点称做死结点
 * 回答结点：满足问题的全部约束的结点 

--------------

###活结点的扩展

---------------

* 每一个活结点只有一次机会成为扩展结点。
* 活结点一旦成为扩展结点，就一次性产生其所有儿子结点。
* 在这些儿子结点中，导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。

------------------

###下一个活结点的生成

-------------------

* **队列式(FIFO)分支限界法**：按照队列先进先出（FIFO）原则选取下一个点为扩展节点。
* **优先队列式分支限界法**: 按照优先队列中规定的优先级选取优先级最高的活结点成为当前扩展节点。

------------------

###结点舍弃原则（剪支策略）
 
-------------------

* 导致不可行解或导致非最优解的儿子结点被舍弃；
* 在算法扩展结点的过程中，一旦发现一个结点的下界不小于（上界不大于）当前找到的最优值，则算法剪去以该结点为根的子树；

-------------------

##装载问题

-------------------

在算法的while循环中，首先检测当前扩展结点的左儿子结点是否为可行结点。如果是则将其加入到活结点队列中。然后将其右儿子结点加入到活结点队列中(右儿子结点一定是可行结点)。2个儿子结点都产生后，当前扩展结点被舍弃。活结点队列中的队首元素被取出作为当前扩展结点，由于队列中每一层结点之后都有一个尾部标记-1，故在取队首元素时，活结点队列一定不空。当取出的元素是-1时，再判断当前队列是否为空。如果队列非空，则将尾部标记-1加入活结点队列，算法开始处理下一层的活结点。

![onepiece](/life/picture/query.png)


 {% highlight C++ %}
 
 Void enQueue(Queue Q,int wt,int bestw,int i,int n)
{    if(i==n)if(wt>bestw)bestw=wt;
      else Q.Add(wt);
}
   int MaxLoading(int w[],int c,int n)
	{   …
   while (true)
   {     
		if (ew + w[i] <= c)        
			enQueue(Q,ew + w[i], bestw,i,n);      // 检查左儿子结点
         enQueue(Q,ew, bestw,i,n);      //右儿子结点总是可行的
         Q.delete(ew);                 // 取下一扩展结点
         if (ew == -1)                // 同层结点尾部标志
         {   if (Q.isEmpty())return bestw;
             Q.Add( -1);            // 同层结点尾部标志
            Q.delete(ew);          // 取下一扩展结点
             i++;                 // 进入下一层      
         } 
     } }
{% endhighlight %}

----------------------

