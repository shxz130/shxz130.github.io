---
layout : life
title : "深入理解jvm之GC(垃圾收集器)"
category : 深入理解JVM
duoshuo: true
date : 2014-11-05
---
------------

#完成的三件事情

-----------

* 哪些内存需要回收？
* 什么时候回收？
* 如何回收？

----------

#如何判断一个对象是否死亡？

------------

###垃圾收集器在对堆进行回收前，第一件事情就是确定这些对象是否存活。

* 引用计数法
* 根搜索算法

----------

#垃圾收集算法

----------

* 标记清除法
* 复制算法
* 标记整理法
* 分代收集算法

-----------

##引用计数法：

----------

* 给对象添加一个引用计数器，每当有一个地方需要引用它时，计数器值+1，当引用失效时，计数器值减1，如何计数器都为0的对象就是不可能为再被使用的。
* **问题**：无法解决对象之间的相互循环引用的问题。

----------
 {% highlight java %}
public class Text{
	public Object instance;
	
	public static void text()
	{
		Text a=new Text();
		Text b=new Text();
		a.instance=b;
		b.instance=a;
		a=null;
		b=null;
		System.gc;
		//假设在这里发生GC，a,b对象是否回收？
	}
}
{% endhighlight %}

-----------------

>由于a有一个引用指向b，b有一个引用指向a,导致相互引用，引用计数不为0，用引用计数法不能及时回收对象a,b。

-----------------

##根搜索算法(GC Roots Tracing)

-----------------

* **基本思路**：通过一系列的名为**GC Roots**的对象作为起点，从这些节点开始向下搜索，搜索走过的路径为引用链，当一个结点到GC Roots没有任何引用链连接，则证明该对象是不可用的，(图中D,E,G对象不可用)
* Java中可以作为GC Roots的对象包括：
	* 虚拟机栈中的引用的对象。
	* 方法区中的类静态属性引用的对象。
	* 方法区的常量引用的对象。
	* 本地方法栈中的JNI(Native方法)的引用的对象。

-------------------

![gengsuanfa](/life/picture/rootsuanfa.png)

-----------------

##标记清除法：

-----------------

* 分为两个阶段：
 * **标记**：标记需要回收的对象。
 * **清除**：标记完成后统一回收掉所有被标记的对象。
* 最基础的**收集算法**，后续的手机算法都是基于这种思路并对其缺点改进而得到的。
* 缺点：
 * **效率问题**：标记和清除过程的效率不高。
 * **空间问题**：标记清除之后会产生大量的**不连续**的**内存碎片**，空间碎片太多会造成以后需要分配较大对象无法找到足够的**连续空间**而不得不提前出发另一次垃圾收集器。

-----------------

![gengsuanfa](/life/picture/biaojiqingchu.png)

----------------

##复制算法

----------------

* 将可用内存划分为大小相等的两块，每次只使用其中一块，当它将这块内存用完之后，将存活的对象复制到另一块上，然后将已使用的内存空间一次清理掉。每次都是对其中一块进行内存回收，分配时不必考虑内存碎片。
* 优点：实现简单，运行高效。
* 缺点：可用内存缩小到原来的一半。

---------------

![fuzhisuanfa](/life/picture/fuzhisuanfa.png)

---------------

##标记整理法

---------------

* 步骤和**标记清除法**基本一样。
* 区别：
	* 不是将对象直接清楚，而是让存活的对象向一端异动，然后直接清理掉边界之外的内存。
	
--------------

![fuzhisuanfa](/life/picture/biaojizhengli.jpg)

--------------

##分代收集法

---------------

* 根据不同的存活周期将内存分为几块，一般是将java堆分为新生代和老年代。根据各个年代的特点采用最合适的手机算法。
* **新生代**：大批死亡，只有少量存活，选择**复制算法**。
* **老年代**：对象存活率高，没有额外空间对它进行分配担保，用**标记清除**，**标记整理法**。

-----------------

