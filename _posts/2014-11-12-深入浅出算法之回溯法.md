---
layout : life
title : "深入浅出算法之回溯法"
category : 深入浅出算法
duoshuo: true
date : 2014-11-12
---

##回溯法

------------

* 为了避免生成那些不可能产生最佳解的问题状态，要不断地利用限界函数(bounding function)来处死那些实际上不可能产生所需解的活结点，以减少问题的计算量。**具有限界函数的深度优先生成法**
* **适用情况**
 * 当需要找出一个问题的解集
 * 要求回答什么解是满足某些约束条件的最佳解。
* 基本做法:**搜索**，或是一种组织得井井有条的能避免不必要搜索的穷举式搜索法。
 * 适用于解一些组合数相当大的问题
* 在问题的解空间树中，按**深度优先策略**，从**根结点**出发搜索解空间树。算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对该结点为根的子树的搜索，逐层向其祖先结点回溯；否则，进入该子树，继续按深度优先策略搜索。
* **回溯法的基本思想**
 * 针对所给问题，定义问题的解空间；
 * 确定易于搜索的解空间结构；
 * 以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。
* **显著特征**
 * **搜索过程中动态产生问题的解空间**
 * 在任何时刻，算法只保存从根结点到当前扩展结点的路径。如果解空间树中从根结点到叶结点的最长路径的长度为h(n)，则回溯法所需的计算空间通常为O(h(n))。而显式地存储整个解空间则需要O(2h(n))或O(h(n)!)内存空间。
* 常用剪枝函数：
 * **约束函数**在扩展结点处剪去不满足约束的子树；
 * **限界函数**剪去得不到最优解的子树。
* **解空间树**
 * **子集树**
 * **排列树**

-------------------

![onepiece](/life/picture/huisu1.png)

------------------

##深度优先的问题状态生成法
* 如果对一个扩展结点R，一旦产生了它的一个儿子C，就把C当做新的扩展结点。
* 在完成对子树C（以C为根的子树）的穷尽搜索之后，将R重新变成扩展结点，继续生成R的下一个儿子（如果存在）
##广度优先的问题状态生成法
* 在一个扩展结点变成死结点之前，它一直是扩展结点


----------------------

##子集树排列树

---------------------

###子集树

--------------
![onepiece](/life/picture/zijishu.png)

* 遍历子集树需**O(2n)**计算时间

 {% highlight C++ %}
    void backtrack (int t)
{
  if (t>n) output(x);
    else
      for (int i=0;i<=n;i++) {
        x[t]=i;
        if (legal(t)) backtrack(t+1);
      }
}
{% endhighlight %}

-------------------

###排列树

------------------
![onepiece](/life/picture/pailieshu.png)
遍历排列树需要**O(n!)**计算时间
 {% highlight C++ %}
void backtrack (int t)
{
  if (t>n) output(x);
    else
      for (int i=t;i<=n;i++) {
        swap(x[t], x[i]);
        if (legal(t)) backtrack(t+1);
        swap(x[t], x[i]);
      }
} 
{% endhighlight %}

------------------------

##装载问题

------------------------

* 有一批共n个集装箱要装上2艘载重量分别为c1和c2的轮船，装载问题要求确定是否有一个合理的装载方案可将这个集装箱装上这2艘轮船。如果有，找出一种装载方案。
* 容易证明，如果一个给定装载问题有解，则采用下面的策略可得到最优装载方案
 * 首先将第一艘轮船尽可能装满；
 * 将剩余的集装箱装上第二艘轮船。
 
![onepiece](/life/picture/huisu_zhuangzai.png)

* 解空间：子集树
* 可行性约束函数(选择当前元素)：![onepiece](/life/picture/huisu_1.png)
* 上界函数(不选择当前元素)：当前载重量cw+剩余集装箱的重量r<=当前最优载重量bestw

------------------

##例如：w={10,40,40},c=50

-----------------
 {% highlight C++ %}
void backtrack (int i)
   {// 搜索第i层结点
         if (i > n)  // 到达叶结点
         {    if(cw>bestw) 
			  {
					for (j=1;j<=n;j++){
						bestx[j]=x[j];
						bestw=cw;
					}
			  }
               return ;
          }
          r -= w[i];
          if (cw + w[i] <= c) // 搜索左子树
          {    x[i] = 1; 
				cw += w[i]; 
				backtrack(i + 1); 
				cw -= w[i]; 
		  }
          if (cw + r > bestw) // 搜索右子树
		  {    x[i] = 0; 
			  backtrack(i + 1);
		  }
		  r += w[i];
   }
{% endhighlight %}

--------------------

##0-1背包

--------------------
 {% highlight C++ %}
   double bound(int i)
   {// 计算上界
      double cleft = c - cw;   // 剩余容量
      double bound = cp;
      // 以物品单位重量价值递减序装入物品
      while (i <= n &&  w[i] <= cleft)
      {
         cleft -= w[i];
         bound += p[i];
         i++;
      }
      // 装满背包
      if (i <= n)     
		bound += p[i] / w[i] * cleft;
      return bound;
   }
{% endhighlight %}

 --------------------
 {% highlight C++ %}
   void knap (int i)
   {// 搜索第i层结点
      if (i > n)  // 到达叶结点
            {if(cp>bestp){
				for (j=1;j<=n;j++)
					bestx[j]=x[j];
					bestp=cp;
				}
               return ;}
      if (cw + w[i] <= c) // 搜索左子树
      {    x[i] = 1; 
		  cw += w[i];
		  cp+=p[i];
           backtrack(i + 1); 
		   cw -= w[i]; 
		   cp-=p[i];
	 }
     if (Bound(i+1) > bestp) // 搜索右子树
     {  x[i] = 0; 
		backtrack(i + 1);     
	}
}
{% endhighlight %}
