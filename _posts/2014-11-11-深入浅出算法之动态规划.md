---
layout : life
title : "深入浅出算法之动态规划"
category : 深入浅出算法
duoshuo: true
date : 2014-11-11
---
------------

##动态规划

------------
* **基本要素**
 * **最优子结构**
  * 问题的最优值包含了其子问题的最优值时，称该问题具有了最优子结构性质。
 * **重叠子问题**
  * 每次产生的子问题都不总是新问题，有些子问题被反复计算多次，利用这种子问题的重叠性质，对每一个子问题只解一次，然后将其保存在一个表格中，当需要解此问题时，只是简单的用常数时间查看一下结果。
* **设计思想**：和**分治法**类似：将一个难以直接解决的大问题，分割成一些规模较小的子问题，先求解子问题，从子问题中得到原问题的解。与分治法不同的是，用动态规划问题求解的问题，经分解得到的子问题往往不是独立的，用分治法去求解，重复的子问题数目太多。
* **解决方案**：用一个表来记录所有已解决的子问题的答案，不管该问题以后是否能用到，只需计算过就将其结果填入表中。
* **适用**：**解最优化问题**
* 设计步骤
 * 找出最优值的性质，刻画其结构特征。
 * 递归的定义最优值。
 * 以自底向上的方式计算出最优值。
 * 根据计算最优值得到的信息，构造最优解。

* 常见问题：
 * **矩阵连乘**
 * **最长公共子序列**
 * **流水作业调度**
 * **背包问题**
 
--------------

##矩阵连乘

-----------

计算三个矩阵连乘{A1，A2，A3}；维数分别为10*100 , 100*5 , 5*50
* 按此顺序计算需要的次数（（A1*A2）*A3）:10X100X5+10X5X50=7500次
* 按此顺序计算需要的次数（A1*（A2*A3））:10X5X50+10X100X50=75000次

所以问题是：如何确定运算顺序，可以使计算量达到最小化。
子问题状态的建模（很关键）：令m[i][j]表示第i个矩阵至第j个矩阵这段的最优解。
* 如果i=j，则m[i][j]这段中就一个矩阵，需要计算的次数为0；
* 如果i>j，则m[i][j]=min{m[i][k]+m[k+1][j]+p[i-1]Xp[k]Xp[j]},其中k,在i与j之间游荡，所以i<=k<j ;
因为你要保证在计算m[i][j]查找m[i][k]和m[k+1][j]的时候，m[i][k]和m[k+1][j]已经计算出来了。
观察坐标的关系图：
![onepiece](/life/picture/dongtai1.png)

 {% highlight C++ %}
void matrixChain(int [] p, int [][] m, int [][] s)
   {
      int n=p.length-1;
      for (int i = 1; i <= n; i++) m[i][i] = 0;
      for (int r = 2; r <= n; r++)
         for (int i = 1; i <= n - r+1; i++) {
            int j=i+r-1;
            m[i][j] = m[i+1][j]+ p[i-1]*p[i]*p[j];
            s[i][j] = i;
            for (int k = i+1; k < j; k++) {
               int t = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j];
               if (t < m[i][j]) {
                 m[i][j] = t;
                 s[i][j] = k;}
               }
            }
   }

{% endhighlight %}
-----------

##最长公共子序列

---------------

* 若给定序列X={x1,x2,…,xm}，则另一序列Z={z1,z2,…,zk}，是X的子序列是指存在一个严格递增下标序列{i1,i2,…,ik}使得对于所有j=1,2,…,k有：zj=xij。例如，序列Z={B，C，D，B}是序列X={A，B，C，B，D，A，B}的**子序列**，相应的递增下标序列为{2，3，5，7}。
* 给定2个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的**公共子序列**。
* 给定2个序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}，找出X和Y的**最长公共子序列**。 

--------------------

设序列X={x1,x2,…,xm}和Y={y1,y2,…,yn}的最长公共子序列为Z={z1,z2,…,zk} ，则
* 若xm=yn，则zk=xm=yn，且zk-1是xm-1和yn-1的最长公共子序列。
* 若xm≠yn ，且zk≠xm，则Z是xm-1和Y的最长公共子序列。
* 若xm≠yn ，且zk≠yn，则Z是X和yn-1的最长公共子序列。
由此可见，2个序列的最长公共子序列包含了这2个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有**最优子结构性质**。 

-------------

由最长公共子序列问题的最优子结构性质建立子问题最优值的递归关系。
用c[i][j]记录序列的最长公共子序列的长度。其中， Xi={x1,x2,…,xi}；Yj={y1,y2,…,yj}。当i=0或j=0时，空序列是Xi和Yj的最长公共子序列。故此时C[i][j]=0。其他情况下，由最优子结构性质可建立递归关系如下：
![onepiece](/life/picture/dongtai2.png)

------------

###计算最优值
####时间复杂度O(m*n)

------------

 {% highlight C++ %}
Void lcsLength(char * x, char * y,int * * c, int ** b)
m=x.length-1;
n=y.length-1;
c[i][0]=0; c[0][i]=0;
for (int i = 1; i <= m; i++)
   for (int j = 1; j <= n; j++) 
      if (x[i]==y[j]) 
          c[i][j]=c[i-1][j-1]+1;
          b[i][j]=1;
       else if (c[i-1][j]>=c[i][j-1]) 
          c[i][j]=c[i-1][j];
          b[i][j]=2;
      else 
           c[i][j]=c[i][j-1];
           b[i][j]=3;
{% endhighlight %}

* 数组C:存放x,y的最长公共子序列
* 数组b:记录c[i][j]的值由哪一个子问题的解得到的值。
-------------

###计算最优解
####时间复杂度O(m+n)

-------------
 {% highlight C++ %}
Void  lcs(int i,int j,char [] x,int [][] b)
   {
      if (i ==0 || j==0) return;
      if (b[i][j]== 1){
        lcs(i-1,j-1,x,b);
        cout<<x[i];
        }
      else if (b[i][j]== 2) lcs(i-1,j,x,b);
        else lcs(i,j-1,x,b);
   }
{% endhighlight %}

* 当b[i][j]=1时，xi,yi的最长公共子序列是由xi-1,yi-1,在尾部加上xi所得到的子序列。
* 当b[i][j]=2时，xi,yi的最长公共子序列和由xi-1,yj的最长公共子序列是相同的。
* 当b[i][j]=3时，xi,yi的最长公共子序列是由xi,yi-1的最长公共子序列是相同的。




